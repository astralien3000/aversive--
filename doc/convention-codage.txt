Convention de nommage :

classe : NomDeClasse               (upper camel case)
fonction membre : nomDeMembre      (lower camel case)
attribut : _nom_attribut           (lower underscore case underscore first)
fonction c style : nom_de_fonction (lower underscore case)
paramètre : nom_parametre          (lower underscore case)
constante : NOM_CONSTANTE          (upper underscore case)
macro/define : NOM_MACRO           (upper underscore case)

Pour les paramêtres de template :
Si le parametre est un type, utiliser la même convention que pour les classes.
Sinon, utiliser la même convention que pour les constantes.

Les types de base (ne vaut que pour les headers) :
Pour les entiers : Utiliser les types définits dans base/integer.hpp
Pour les flottants : float UNIQUEMENT (peut changer sous peu !)


Convention de codage :

Indentation :
Quatre espaces en guise d'indentation.

Templates :

déclaration =>
template<...> type nom_fonction(...);

définition =>
template<...>
type nom_fonction {

}

idem pour les classes template/fonction membres, etc

Braces (accolades) :

Pas de retour à la ligne pour l'ouverture d'un bloc quelconque.

exemples :

if(...) {
     ...
}
else {
     ...
}

type func(...) {
     ...
}

for(... ; ... ; ...) {
     ...
}

Si le bloc est vide, ceci et autorisé :
type func(...) {}

Pour les boucles et branchement conditionnels, 
mettre les accolades même si il n'y a qu'une insctuction.

Si la fonction ne prend aucun paramètre, écrire void entre les parenthèses.


Convention de conception :

Règle générale : tout ce qui peut être résolu à la compilation doit 
être résolu à la compilation.

Si la fonction est très coutre (trois instructions maxi), 
ou l'algo peut être résolu à la compilation (regarder l'asm pour vérifier),
mettre la fonction inline et le code dans le header.

Privilégier les fonctions templates aux branchements conditionnels.

Exmple :

enum Test {
     TEST1,
     TEST2
};

// MAUVAIS
void test(enum Test t) {
     if(t == TEST1) {
     	  ...
     }
     else if(t == TEST2) {
     	  ...
     }
}

// MIEUX
template<enum Test T>
void test(void);

template<>
void test<TEST1>(void) {
    ...
}

template<>
void test<TEST2>(void) {
    ...
}

Utiliser le mot-clé const au moment opportun.
(Je vais pas vous apprendre à programmer en POO)

Lorsque l'implémentation d'une classe est différente selon l'architecture :
Déclarer un nouveau type dans la classe appelé PrivateData.
Déclarer un attribut de type PrivateData.
Définir ce type dans le header spécialisé de l'architecture.

Documentation du code :

En anglais !

On utilise doxygen, avec les balises suivantes :

//! ligne de doc
//! autre ligne de doc
//! ...
